name: Status Badges Update

on:
  push:
    branches: [main]
  schedule:
    # Update badges daily
    - cron: '0 12 * * *'
  workflow_dispatch:

jobs:
  # Generate dynamic status badges
  update-badges:
    name: Update Status Badges
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: badges-${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y pkg-config libssl-dev jq

    - name: Collect repository metrics
      run: |
        mkdir -p badges_data

        # Get basic project info
        CARGO_VERSION=$(cargo metadata --format-version 1 | jq -r '.packages[] | select(.name == "inferno") | .version')
        echo "version=$CARGO_VERSION" >> badges_data/project.env

        # Get latest release info
        LATEST_RELEASE=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/latest" | jq -r '.tag_name // "none"')
        echo "latest_release=$LATEST_RELEASE" >> badges_data/project.env

        # Count lines of code
        RUST_LOC=$(find src -name "*.rs" -exec wc -l {} + | tail -1 | awk '{print $1}')
        echo "rust_loc=$RUST_LOC" >> badges_data/project.env

        # Count total files
        TOTAL_FILES=$(find src -name "*.rs" | wc -l)
        echo "total_files=$TOTAL_FILES" >> badges_data/project.env

        # Check if tests exist
        if cargo test --no-run > /dev/null 2>&1; then
          echo "tests_status=passing" >> badges_data/project.env
        else
          echo "tests_status=failing" >> badges_data/project.env
        fi

        # Get last commit date
        LAST_COMMIT=$(git log -1 --format=%cd --date=short)
        echo "last_commit=$LAST_COMMIT" >> badges_data/project.env

        # Get CI status from latest workflow run
        CI_STATUS=$(curl -s "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=completed&branch=main&per_page=1" \
          | jq -r '.workflow_runs[0].conclusion // "unknown"')
        echo "ci_status=$CI_STATUS" >> badges_data/project.env

    - name: Generate code coverage badge
      run: |
        # Try to get coverage from Codecov API
        CODECOV_COVERAGE=$(curl -s "https://codecov.io/api/gh/${{ github.repository }}" | jq -r '.commit.totals.c // "unknown"')

        if [[ "$CODECOV_COVERAGE" != "unknown" && "$CODECOV_COVERAGE" != "null" ]]; then
          COVERAGE_PCT=$(echo "$CODECOV_COVERAGE" | awk '{printf "%.1f", $1}')
          echo "coverage=$COVERAGE_PCT" >> badges_data/project.env

          # Determine coverage color
          if (( $(echo "$COVERAGE_PCT >= 90" | bc -l) )); then
            COVERAGE_COLOR="brightgreen"
          elif (( $(echo "$COVERAGE_PCT >= 80" | bc -l) )); then
            COVERAGE_COLOR="green"
          elif (( $(echo "$COVERAGE_PCT >= 70" | bc -l) )); then
            COVERAGE_COLOR="yellow"
          elif (( $(echo "$COVERAGE_PCT >= 60" | bc -l) )); then
            COVERAGE_COLOR="orange"
          else
            COVERAGE_COLOR="red"
          fi
          echo "coverage_color=$COVERAGE_COLOR" >> badges_data/project.env
        else
          echo "coverage=unknown" >> badges_data/project.env
          echo "coverage_color=lightgrey" >> badges_data/project.env
        fi

    - name: Check security audit status
      run: |
        if cargo audit > /dev/null 2>&1; then
          echo "security_status=secure" >> badges_data/project.env
          echo "security_color=brightgreen" >> badges_data/project.env
        else
          echo "security_status=vulnerabilities" >> badges_data/project.env
          echo "security_color=red" >> badges_data/project.env
        fi

    - name: Generate badges JSON
      run: |
        source badges_data/project.env

        # Create badges configuration
        cat > badges_data/badges.json << EOF
        {
          "schemaVersion": 1,
          "badges": {
            "version": {
              "label": "version",
              "message": "$version",
              "color": "blue",
              "style": "flat-square"
            },
            "release": {
              "label": "release",
              "message": "$latest_release",
              "color": "blue",
              "style": "flat-square"
            },
            "lines_of_code": {
              "label": "lines of code",
              "message": "${rust_loc}",
              "color": "informational",
              "style": "flat-square"
            },
            "coverage": {
              "label": "coverage",
              "message": "${coverage}%",
              "color": "$coverage_color",
              "style": "flat-square"
            },
            "security": {
              "label": "security",
              "message": "$security_status",
              "color": "$security_color",
              "style": "flat-square"
            },
            "ci_status": {
              "label": "ci",
              "message": "$ci_status",
              "color": "$([ "$ci_status" = "success" ] && echo "brightgreen" || echo "red")",
              "style": "flat-square"
            },
            "rust_version": {
              "label": "rust",
              "message": "$(rustc --version | cut -d' ' -f2)",
              "color": "orange",
              "style": "flat-square"
            },
            "license": {
              "label": "license",
              "message": "MIT OR Apache-2.0",
              "color": "green",
              "style": "flat-square"
            }
          }
        }
        EOF

    - name: Generate README badges section
      run: |
        source badges_data/project.env

        cat > badges_data/badges_section.md << 'EOF'
        <!-- START BADGES -->
        [![CI](https://github.com/${{ github.repository }}/workflows/Enhanced%20CI%20Pipeline/badge.svg)](https://github.com/${{ github.repository }}/actions/workflows/ci-enhanced.yml)
        [![Release](https://img.shields.io/github/v/release/${{ github.repository }}?style=flat-square)](https://github.com/${{ github.repository }}/releases)
        [![Crates.io](https://img.shields.io/crates/v/inferno?style=flat-square)](https://crates.io/crates/inferno)
        [![Documentation](https://docs.rs/inferno/badge.svg)](https://docs.rs/inferno)
        [![License](https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-green?style=flat-square)](LICENSE)
        [![codecov](https://codecov.io/gh/${{ github.repository }}/branch/main/graph/badge.svg)](https://codecov.io/gh/${{ github.repository }})
        [![Security Audit](https://github.com/${{ github.repository }}/workflows/Security%20Audit/badge.svg)](https://github.com/${{ github.repository }}/actions)
        [![Docker](https://img.shields.io/docker/pulls/inferno-ai/inferno?style=flat-square)](https://hub.docker.com/r/inferno-ai/inferno)
        <!-- END BADGES -->
        EOF

    - name: Generate project dashboard
      run: |
        source badges_data/project.env

        cat > badges_data/project_dashboard.md << EOF
        # ðŸ“Š Project Dashboard

        ## ðŸš€ Quick Stats

        | Metric | Value |
        |--------|-------|
        | **Current Version** | \`$version\` |
        | **Latest Release** | \`$latest_release\` |
        | **Lines of Rust Code** | \`$rust_loc\` |
        | **Total Rust Files** | \`$total_files\` |
        | **Last Commit** | \`$last_commit\` |
        | **CI Status** | \`$ci_status\` |
        | **Security Status** | \`$security_status\` |
        | **Test Coverage** | \`$coverage%\` |

        ## ðŸ”— Quick Links

        - [ðŸ“š Documentation](https://docs.rs/inferno)
        - [ðŸ“¦ Crates.io](https://crates.io/crates/inferno)
        - [ðŸ³ Docker Hub](https://hub.docker.com/r/inferno-ai/inferno)
        - [ðŸ”„ CI/CD Status](https://github.com/${{ github.repository }}/actions)
        - [ðŸ“Š Code Coverage](https://codecov.io/gh/${{ github.repository }})
        - [ðŸ·ï¸ Latest Release](https://github.com/${{ github.repository }}/releases/latest)

        ## ðŸ“ˆ Repository Health

        ![GitHub issues](https://img.shields.io/github/issues/${{ github.repository }}?style=flat-square)
        ![GitHub pull requests](https://img.shields.io/github/issues-pr/${{ github.repository }}?style=flat-square)
        ![GitHub stars](https://img.shields.io/github/stars/${{ github.repository }}?style=flat-square)
        ![GitHub forks](https://img.shields.io/github/forks/${{ github.repository }}?style=flat-square)
        ![GitHub contributors](https://img.shields.io/github/contributors/${{ github.repository }}?style=flat-square)

        ---
        *Dashboard auto-updated on $(date -u)*
        EOF

    - name: Upload badge data
      uses: actions/upload-artifact@v4
      with:
        name: badges-data
        path: badges_data/
        retention-days: 30

    - name: Update GitHub Pages with dashboard
      if: github.ref == 'refs/heads/main'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: badges_data
        destination_dir: dashboard
        keep_files: true

  # Update repository topics and metadata
  update-repository-metadata:
    name: Update Repository Metadata
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update repository topics
      uses: actions/github-script@v7
      with:
        script: |
          // Define topics based on project content
          const topics = [
            'rust',
            'ai',
            'machine-learning',
            'ml',
            'gguf',
            'onnx',
            'inference',
            'llm',
            'neural-networks',
            'deep-learning',
            'model-serving',
            'api',
            'cli',
            'tui',
            'enterprise',
            'performance',
            'gpu-acceleration',
            'distributed-computing',
            'microservices',
            'docker',
            'kubernetes',
            'monitoring',
            'observability',
            'benchmark'
          ];

          try {
            await github.rest.repos.replaceAllTopics({
              owner: context.repo.owner,
              repo: context.repo.repo,
              names: topics
            });
            console.log('Repository topics updated successfully');
          } catch (error) {
            console.log('Failed to update repository topics:', error.message);
          }

    - name: Update repository description
      uses: actions/github-script@v7
      with:
        script: |
          const description = "ðŸ”¥ Enterprise-grade offline AI/ML model runner supporting GGUF and ONNX formats with distributed inference, monitoring, and GPU acceleration";
          const homepage = "https://inferno-ai.dev";

          try {
            await github.rest.repos.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              description: description,
              homepage: homepage
            });
            console.log('Repository description updated');
          } catch (error) {
            console.log('Failed to update repository description:', error.message);
          }

  # Generate shields.io endpoints
  generate-shields:
    name: Generate Custom Shields
    runs-on: ubuntu-latest
    needs: update-badges
    timeout-minutes: 10

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download badge data
      uses: actions/download-artifact@v4
      with:
        name: badges-data
        path: badges_data

    - name: Generate shields.io endpoints
      run: |
        mkdir -p shields_endpoints

        # Create JSON endpoints for shields.io
        source badges_data/project.env

        # Version endpoint
        cat > shields_endpoints/version.json << EOF
        {
          "schemaVersion": 1,
          "label": "version",
          "message": "$version",
          "color": "blue"
        }
        EOF

        # Coverage endpoint
        cat > shields_endpoints/coverage.json << EOF
        {
          "schemaVersion": 1,
          "label": "coverage",
          "message": "${coverage}%",
          "color": "$coverage_color"
        }
        EOF

        # Lines of code endpoint
        cat > shields_endpoints/loc.json << EOF
        {
          "schemaVersion": 1,
          "label": "lines of code",
          "message": "$rust_loc",
          "color": "informational"
        }
        EOF

        # Security status endpoint
        cat > shields_endpoints/security.json << EOF
        {
          "schemaVersion": 1,
          "label": "security",
          "message": "$security_status",
          "color": "$security_color"
        }
        EOF

        # CI status endpoint
        cat > shields_endpoints/ci.json << EOF
        {
          "schemaVersion": 1,
          "label": "ci",
          "message": "$ci_status",
          "color": "$([ "$ci_status" = "success" ] && echo "brightgreen" || echo "red")"
        }
        EOF

    - name: Deploy shields endpoints
      if: github.ref == 'refs/heads/main'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: shields_endpoints
        destination_dir: shields
        keep_files: false

  # Repository health check
  repository-health:
    name: Repository Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check repository health
      uses: actions/github-script@v7
      with:
        script: |
          const health = {
            hasReadme: false,
            hasLicense: false,
            hasContributing: false,
            hasCodeOfConduct: false,
            hasIssueTemplate: false,
            hasPrTemplate: false,
            hasWorkflows: false,
            hasDocumentation: false,
            score: 0
          };

          // Check for essential files
          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'README.md'
            });
            health.hasReadme = true;
            health.score += 20;
          } catch (e) {}

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'LICENSE'
            });
            health.hasLicense = true;
            health.score += 15;
          } catch (e) {
            try {
              await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'LICENSE.md'
              });
              health.hasLicense = true;
              health.score += 15;
            } catch (e) {}
          }

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'CONTRIBUTING.md'
            });
            health.hasContributing = true;
            health.score += 10;
          } catch (e) {}

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'CODE_OF_CONDUCT.md'
            });
            health.hasCodeOfConduct = true;
            health.score += 10;
          } catch (e) {}

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: '.github/ISSUE_TEMPLATE'
            });
            health.hasIssueTemplate = true;
            health.score += 10;
          } catch (e) {}

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: '.github/pull_request_template.md'
            });
            health.hasPrTemplate = true;
            health.score += 5;
          } catch (e) {}

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: '.github/workflows'
            });
            health.hasWorkflows = true;
            health.score += 15;
          } catch (e) {}

          try {
            await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'docs'
            });
            health.hasDocumentation = true;
            health.score += 15;
          } catch (e) {}

          // Generate health report
          const healthLevel = health.score >= 80 ? 'Excellent' :
                             health.score >= 60 ? 'Good' :
                             health.score >= 40 ? 'Fair' : 'Needs Improvement';

          console.log('Repository Health Report:');
          console.log(`Overall Score: ${health.score}/100 (${healthLevel})`);
          console.log(`README: ${health.hasReadme ? 'âœ…' : 'âŒ'}`);
          console.log(`License: ${health.hasLicense ? 'âœ…' : 'âŒ'}`);
          console.log(`Contributing Guide: ${health.hasContributing ? 'âœ…' : 'âŒ'}`);
          console.log(`Code of Conduct: ${health.hasCodeOfConduct ? 'âœ…' : 'âŒ'}`);
          console.log(`Issue Templates: ${health.hasIssueTemplate ? 'âœ…' : 'âŒ'}`);
          console.log(`PR Template: ${health.hasPrTemplate ? 'âœ…' : 'âŒ'}`);
          console.log(`CI/CD Workflows: ${health.hasWorkflows ? 'âœ…' : 'âŒ'}`);
          console.log(`Documentation: ${health.hasDocumentation ? 'âœ…' : 'âŒ'}`);

          // Create health badge
          const healthColor = health.score >= 80 ? 'brightgreen' :
                             health.score >= 60 ? 'green' :
                             health.score >= 40 ? 'yellow' : 'red';

          console.log(`Health Badge: ![Repository Health](https://img.shields.io/badge/health-${health.score}%25-${healthColor})`);

  # Generate comprehensive status report
  status-report:
    name: Generate Status Report
    runs-on: ubuntu-latest
    needs: [update-badges, update-repository-metadata, generate-shields, repository-health]
    if: always()

    steps:
    - name: Generate status report
      run: |
        cat > status_report.md << 'EOF'
        # ðŸ“Š Repository Status Report

        **Generated:** $(date -u)
        **Repository:** ${{ github.repository }}

        ## ðŸ† Status Summary

        | Component | Status |
        |-----------|--------|
        | Badge Updates | ${{ needs.update-badges.result }} |
        | Metadata Updates | ${{ needs.update-repository-metadata.result }} |
        | Shields Generation | ${{ needs.generate-shields.result }} |
        | Health Check | ${{ needs.repository-health.result }} |

        ## ðŸ”— Quick Access

        - [ðŸ“Š Project Dashboard](https://github.com/${{ github.repository }}/pages/dashboard)
        - [ðŸ›¡ï¸ Shields Endpoints](https://github.com/${{ github.repository }}/pages/shields)
        - [ðŸ“ˆ GitHub Insights](https://github.com/${{ github.repository }}/pulse)
        - [ðŸ”„ Actions](https://github.com/${{ github.repository }}/actions)

        ## ðŸ“ Next Steps

        - Monitor badge accuracy and update frequency
        - Review repository health recommendations
        - Ensure all links are working correctly
        - Consider adding more custom metrics

        ---
        *This report is automatically generated by the badges workflow*
        EOF

        echo "Status report generated successfully"

    - name: Upload status report
      uses: actions/upload-artifact@v4
      with:
        name: status-report
        path: status_report.md
        retention-days: 7